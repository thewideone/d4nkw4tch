#include <avr/io.h>
#include <avr/power.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/eeprom.h>

#include <stdint.h>

#include <stdlib.h>
#include <avr/wdt.h>

#include "pin_desc.h"
#include "scale8.h"

#include "bitmaps/power_bitmaps.h"
#include "button_debounce/debounce.h"
#include "BQ32002_lib/bq32002.h"
#include "I2C_TWI/i2c_twi.h"
#include "oled_lib/ssd1306.h"
#include "uart_lib/uart.h"

#include "led.h"
#include "button_debounce/buttons.h"
#include "buzzer.h"
#include "date_time.h"
#include "power_adc_wdt.h"
#include "anims/menu_pointers.h"
#include "anims/misc.h"
#include "menus.h"

extern volatile TMENU menu;		// = menu_main;

extern volatile uint8_t stayUpTime;// = STAY_UP_TIME;

extern volatile uint8_t wakeUpTime;

uint8_t bit_settings;	// description in power_adc_wdt.h

//char bt_buf[BT_BUF_LENGTH];
//uint8_t bt_buf_index = 0;
//extern uint8_t bt_terminal_cursor_x=65;
//extern uint8_t bt_terminal_cursor_y=0;

//extern uint8_t bitSettings;
//extern uint8_t bitSettingsEEMEM EEMEM;

/*
struct small_int{
	unsigned var : 2;
};
struct small_int appCursor = {.var = 0};
*/
/*
	TODO:
	- add watchface variable to select different watchfaces instead of astronaut bit in bit settings
	- change battery level to smooth transition using drawing lines instead of bitmaps
	- strzalka w menu lata w tybie ciaglym
	- niech kropka w menu sie uspokoi XD
	- przeniesc czytanie sqw do ISR
	- wykrywanie Oscillator Fail Flag od RTC
	- dodac wyswietlanie zera w tostring() w ssd1306_put_int()
	- dzien tygodnia wychodzi poza days[][] w poniedzialki
	- po obudzeniu obraz jest wyświetlany dopiero przy zmianie stanu rtc int - poprawić
	- watchdog wyłącza zegarek gdy się usypia i jest uspany!
	- low power consumption using DIDR0 register https://www.avrfreaks.net/forum/tristate-input-what-use-them
	- add some flexibility to arrow animations because for example the arrow doesn't roll in menu_set_date_and_time
	- arrow roll in menu_settings & menu_sound_settings & volume...
	- in menu_set_date_time arrow doesn't point directly on values
	- X change menu_cursor_x's to appCursor etc (and change their name), all the menus have some common variables
	- X auto power saving mode when Vcc low
	- turn off BLE LED option: "AT+PIO11" - 1: unconnected: out low, connected: out high
	- 68Ohm resistor for brighter led
	- X ((datetime.ss-wakeUpTime) < stayUpTime) in main loop not working when minute changes
	- X poll RTC only if connected to RTC INT pin's state's changed
	- X zrobić efekt wyłączania starego TV przed wyłączeniem się ekranu + może trochę glitchu?, w Aseprite
	- funkcja przenoszaca fragmenty obrazu (przenoszenie stralki w menu jest szybsze niz rysowanie od nowa
											+ strzalka nie musi miec ramki z czarnych pixeli)
	-code optimalization
	-ograniczenia kursora
	-OCR0B (i nie tylko) value into EEPROM
	-uint8_t bt_enabled = 0/1 in EEPROM
	-screen sometimes stays up (maybe add cli() in some places), see this: https://www.norwegiancreations.com/2018/10/arduino-tutorial-avoiding-the-overflow-issue-when-using-millis-and-micros/
	- X RTC interrupt handle
	- X new pcbs - change power connections
	- X usb plug sense
	-time in different timezones
	-make bt string transmission (BLE allows for transmission of 20 bytes max at once)
	-make bit and predator clock
	-make starship game
	-make game of life
	- pong with changing player after bounce

	Hardware debugging:
	- make a power wire with ammeter
	- the screen seems not to be broken even when it doesn't light up for a while
	- capacitor / resistor values from the website (https://learn.adafruit.com/monochrome-oled-breakouts/downloads)
	- schematic http://wiki.sunfounder.cc/index.php?title=OLED-SSD1306_Module
	- schematic https://wiki.52pi.com/index.php/0.91_OLED_(English)
	- schematic https://wiki.banana-pi.org/BPI_OLED_Display_Module
		- SCK and MOSI 10k pull-ups
	- desolder speaker from 5.0V?
	- desolder battery charger
	- disconnect D3-D7 ?

	Notes:
	Console colour in Eclipse can be changed in Window > Preferences > C/C++ > Build > Console
*/

// Section .init3 is used in this example, as this ensures the internal
// __zero_reg__ has already been set up. The code generated by the compiler
// might blindly rely on __zero_reg__ being really 0.
// In other words, in C programs .init2 is weakly bound to initialize the stack,
// and to clear zero_reg (r1), so .init3 seems like a safe place to put this code into.
// https://www.nongnu.org/avr-libc/user-manual/mem_sections.html
void __init3( void ) __attribute__ (( section( ".init3" ), naked, used ));
void __init3( void )
{
    /* wyłączenie watchdoga (w tych mikrokontrolerach, w których watchdog
     * ma możliwość generowania przerwania pozostaje on też aktywny po
     * resecie) */

    MCUSR = 0;
    WDTCSR = (1<<WDCE) | (1<<WDE);
    WDTCSR = 0;
}

int main(){

	/* INIT SECTION */
	wdt_enable(WDTO_2S);
	uart_init(UBRRVAL);	// BT off on startup?
	ssd1306_init( SSD1306_SWITCHCAPVCC, REFRESH_MAX );

	setupADC();

	// I/O SETUP
	setupBattAndPlugSense();
	setupLED();
	setupBuzzer();	// uses Timer0
	setupButtons();	// uses Timer2

	setButtonsHoldOff();

	RTC_INT_DDR &= ~(1<<RTC_INT);		//
	RTC_INT_PORT |= (1<<RTC_INT);		// enable pull-up

	// INTERRUPTS SETUP
	PCICR |= (1 << PCIE1) | (1 << PCIE2);				// BUTTON & BATT STAT
	PCMSK1 |= (1<<PCINT11) | (1<<PCINT10) | (1<<PCINT9);	// BUTTON
	PCMSK2 |= (1<<PCINT20);//|(1<<PCINT19);	// BATT STAT

	// RTC setup
	BQ32002_init();
	BQ32002_disableOsc();
	BQ32002_enableOsc();
	BQ32002_setCalSign(1);	// speed up the RTC
	BQ32002_setCalValue(31);
	BQ32002_setCalFreq( 1 );	// set 1Hz output
	BQ32002_enableFreqTest();	// enable the output

//	BQ32002_setDate( 22, 12, 7, 1 );

	sei();

	while(1){
		/*	Sleep	*/
		//tx_string("AT+SLEEP");
		//BATT_EN_PORT &= ~(1<<BATT_EN);	// Disable the divider
		BQ32002_disableFreqTest();	// disable the output
		ssd1306_cmd( SSD1306_DISPLAYOFF );
//		wdt_disable_mod();			// Disable Watchdog, so it won't reset MCU when it's asleep
		WDTCSR = (1<<WDCE) | (1<<WDE);
		WDTCSR = 0;
		power_down;
		sleep_enable;
		sei();
		sleep_cpu;
		sleep_disable;

		/* Wake up */
		wdt_enable(WDTO_2S);	// Enable Watchdog
		ssd1306_init( SSD1306_SWITCHCAPVCC, REFRESH_MAX );
		ssd1306_cmd( SSD1306_DISPLAYON );

		bit_settings = readBitSettings();

		if( bit_is_set( bit_settings, BUTTON_SOUND_BIT ) )
			OCR0B = BUTTON_CLICK_OCR0B_VALUE;
		else
			OCR0B = 250;	// put this into PROGMEM

		readVcc();
		handlePowerSettings( bit_settings );

		ssd1306_cls();
		menu = menu_main;

		BQ32002_enableFreqTest();	// enable the output
		BQ32002_getDateTime( &datetime );

		gotoMenu( menu_main );
		wakeUpTime = datetime.ss;

		sei();

		/*	Main loop	*/
		while( abs(datetime.ss-wakeUpTime) < stayUpTime || bit_is_set( PCIFR,PCIF1 ) ||
			   ( (menu != menu_main) && abs(datetime.ss-wakeUpTime) < stayUpTime*3 )    ){

			wdt_reset();
			getDateTime( &datetime );
			handleButtons();

			if( buzzerState() == ON && getButtonState() != NONE )
				buzzerEnable();
			else buzzerDisable();

			switch(menu){
				default:
					handleMenuDefault( &datetime, wakeUpTime, stayUpTime );
					break;
/* MAIN MENU */	case menu_main:
					handleMenuMain( &datetime );
					break;
/* APP MENU */	case menu_apps:
					handleMenuApps();
					break;
/* FLASHLIGHT */case menu_flashlight:
					if( getButtonState() == PRESS ){
						LED_OFF;
						LED2_OFF;
						handlePowerSettings( bit_settings );
						gotoMenu( menu_apps );
					}
					break;
/*   MENU 	*/	case menu_settings:
/* SETTINGS */		handleMenuSettings( &bit_settings );
/*   MENU 	*/		break;
/* LOUDNESS */	case menu_sound_settings:
					handleMenuSoundSettings();
/*  MENU 	*/		break;
				case menu_volume:
					handleMenuVolume();
					break;
/* SET D&T */	case menu_set_date_and_time:
					getDateTime( &datetime );
					handleMenuSetDateTime();
					break;
/*BT TERMINAL*/	case menu_bt_terminal:
					handleMenuBtTerminal();
					break;
/*  MENU BT  */	case menu_bt:
					handleMenuBt();
					break;
			}
			ssd1306_display();
			updateSqwState();
		}
		// If not in power-saving mode
		if( bit_is_set( bit_settings, PWR_SAVING_MODE_BIT ) ){
			wdt_reset();
			anim_display_off();	// also includes wdt_reset()
		}
	}
}

// Interrupt vector for PORTC,
// which includes buttons.
ISR(PCINT1_vect){
	wakeUpTime = datetime.ss;
}

// Interrupt vector for PORTD,
// which includes charger input
ISR(PCINT2_vect){
	wakeUpTime = datetime.ss;
}
